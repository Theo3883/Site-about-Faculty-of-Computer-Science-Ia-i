<!DOCTYPE html>
<link rel="stylesheet" type="text/css" href="designadmitere2017.css">
<html>

<head>
    <title>Admitere 2017</title>
</head>

<body>
    <button class="top-button">Top</button>
    <script src="script.js"></script>
    <div class="black-bar">
        <div class="button-container">
            <a href="code.html"><button class="button" style="margin-right: 30px;">Home</button></a>
            <a href="informatii.html"><button class="button" style="margin-right: 30px;">Informații</button></a>
            <a href="admitere2018.html"><button class="button" style="margin-right: 30px;">Admitere 2018</button></a>
            <a href="admitere2019.html"><button class="button" style="margin-right: 30px;">Admitere 2019</button></a>
        </div>
    </div>
    <div class="container">
        <div class="text-box">
            <h2 class="title">
                <p>&nbsp &nbsp Admitere Informatică Iași 2017 &nbsp &nbsp Subiecte și rezolvări</p>
            </h2>
        </div>
        <div class="text-box">
            <h1>Subiectul I. Problema 1</h1>
            <div class="other-box">
                <p>
                    Fie x o variabilă întreagă care conține cel mai mic număr natural nenul, multiplu de 36 divizibil cu
                    toate numerele prime mai mici decât 10. Precizați care dintre expresiile C++ de mai jos este
                    adevărată. <br>
                    <b>A. &nbsp&nbsp&nbsp</b> <i>(x < 1000) && (x % 27==0)</i><br>
                            <b>B. &nbsp&nbsp&nbsp</b> <i>(x > 1000) && ((x * x * x) % 1000 == 0</i><br>
                            <b>C. &nbsp&nbsp&nbsp</b> <i>((x * x) / 16) % 2 == 0</i><br>
                            <b>D. &nbsp&nbsp&nbsp</b> <i>(x % 100 == 0) || (x / 100 == 0)</i><br>
                            <div class="text-explicatie">
                                Numerele prime mai mici decât 10 sunt 2, 3, 5 și 7, deci variabila x este egală cu
                                cmmmc(2,3,5,7,36)=1260cmmmc(2,3,5,7,36)=1260. Acum trebuie să evaluăm fiecare expresie
                                dată în parte. <b>A</b> este falsă deoarece 1260 > 1000. <b>B</b> este adevărată pentru
                                că 1260 > 1000 și x * x * x este divizibil cu 1000, căci se termină în trei zerouri.
                                <b>C</b> este falsă deoarece (x * x) / 16 == 99225, care este impar. <b>D</b> este falsă
                                pentru că nici x % 100 == 0 și nici x / 100 == 0 nu sunt adevărate. Așadar, varianta
                                corectă este <b>B</b>
                            </div>
                </p>
            </div>
        </div>
        <div class="text-box">
            <h1>Subiectul I. Problema 2</h1>
            <div class="other-box">
                <p>Se consideră subprogramul F de mai jos, descris în pseudocod. Subprogramul primește un număr natural
                    nenul în parametrul u și întoarce un număr natural când se oprește.</p>
                <div class="code-block">
                    <p>
                    <div class="code-text">
                        <div>&nbsp &nbsp subprogram F(u)<br></div>
                        <div>&nbsp &nbsp &nbsp &nbsp(u - număr natural nenul)<br></div>
                        <div>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp count <- 0<br>
                        </div>
                        <div>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp cât timp u !=1<br> </div>
                        <div>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp dacă u este par</div>
                        <div>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp u <- u /2<br>
                        </div>
                        <div>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp altfel<br></div>
                        <div>&nbsp &nbsp &nbsp&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp u <- u * 3 + 1<br>
                        </div>
                        <div>&nbsp &nbsp&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp count <- count+ 1 <br>
                        </div>
                        <div>&nbsp &nbsp &nbsp&nbsp &nbsp &nbspreturnează count</div>
                        </p>

                    </div>
                </div>
                <b>a)</b> Care este valoarea returnată de subprogram pentru parametrul u=10?
            </div>
            <div class="text-explicatie">
                Iată valorile variabilelor <i>u</i> și <i>count</i> după fiecare intrare în while:
                <div class="image-box">
                    <img src="first-tabel.jpg" alt="My image">
                </div>
                Răspunsul este 6.
            </div>
            <div class="other-box">
                <b>b)</b> Dați exemplu de un număr natural u astfel încât F(u) să returneze 7.
            </div>
            <div class="text-explicatie">
                Trebuie să găsim un număr pentru care se efectuează 7 operații. Cel mai simplu ar fi să-l facem să
                treacă mereu prin prima ramură a if-ului, pentru a-i afla ușor valoarea. Observăm că
                F(2<sup>n</sup>)returnează n, deoarece 2<sup>n</sup> va trebui să se înjumătățească de n ori pentru a
                deveni 1. Deci, un răspuns posibil este 2<sup>7</sup>, adică 128.
            </div>
            <div class="other-box">
                <b>c)</b> Scrieți în pseudocod un subprogram recursiv, echivalent cu F, care nu folosește instrucțiuni
                repetitive.
            </div>
            <div class="text-explicatie">
                Privim fiecare intrare în while a lui u ca pe un apel recursiv ce îl are ca parametru pe noul u.
                Subprogramul recursiv cerut va arăta cam așa:
            </div>
            <div class="code-block">
                <div class="code-text">
                    <p>
                    <div>&nbsp &nbsp subprogram subprogram F(u)</div>
                    <div>&nbsp &nbsp &nbsp &nbsp (u - număr natural nenul)</div>
                    <div> &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp dacă u = 1 atunci</div>
                    <div> &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp returnează 0</div>
                    <div> &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp dacă u este par atunci</div>
                    <div> &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp returnează 1 + F(u / 2)</div>
                    <div>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp returnează 1 + F(u * 3 + 1)</div>
                    </p>
                </div>
            </div>
            <div class="other-box">
                <b>d)</b> Scrieți o funcție C++ care implementează subprogramul F dat.
            </div>
            <div class="text-explicatie">
                Un răspuns posibil este:
            </div>
            <div class="code-block">
                <div class="code-text">
                    <div>&nbsp &nbsp int F(int u) {</div>
                    <div> &nbsp &nbsp &nbsp &nbsp int count = 0;</div>
                    <div> &nbsp &nbsp &nbsp &nbsp while (u != 1) {</div>
                    <div> &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp if (u % 2 == 0)</div>
                    <div> &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp u /= 2;</div>
                    <div> &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp else</div>
                    <div> &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp u = u * 3 + 1;</div>
                    <div> &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcount++;</div>
                    <div> &nbsp &nbsp &nbsp &nbsp}</div>
                    <div>&nbsp &nbsp &nbsp &nbspreturn count;</div>
                    <div>&nbsp &nbsp }</div>
                </div>
            </div>
        </div>
        <div class="text-box">
            <h1>Subiectul II. Problema 1</h1>
            <div class="other-box">
                Care este numărul maxim de noduri de grad 3 într-un graf neorientat cu 5 noduri?<br>
                <b>A.</b>&nbsp 2<br>
                <b>B.</b>&nbsp 3<br>
                <b>C.</b>&nbsp 4<br>
                <b>D.</b>&nbsp 5<br>
            </div>
            <div class="text-explicatie">
                Numărul maxim de noduri de grad 3 într-un graf neorientat cu 5 noduri este <i><b>4</b></i>, și se atinge
                când 4 dintre
                noduri formează un subgraf complet, iar al 5-lea nod rămâne izolat. Deci, varianta corectă este
                <i><b>C</b></i>.
            </div>
        </div>
        <div class="text-box">
            <h1>Subiectul II. Problema 2</h1>
            <div class="other-box">
                Fie un graf neorientat cu mulțimea nodurilor {1,2,…,2015}. Două noduri i și j sunt unite printr-o muchie
                dacă și numai dacă maxmax(i,j)=2min(i,j) sau max(i,j)=2min(i,j)+1. Care este numărul de muchii ale
                acestui graf?
            </div>
            <div class="text-explicatie">
                Reformulând proprietatea dată, în graf există muchia 
                [i,j], cu j>i, dacă și numai dacă [j/2]=i. Evident, pentru fiecare număr 
                j din mulțimea nodurilor există exact un i astfel încât [j/2]=i, și deci fiecărui număr îi corespunde
                exact o muchie. Excepție face  1, deoarece [1/2]=0, care nu aparține mulțimii nodurilor. Așadar,
                răspunsul este 2014, varianta corectă fiind C. Se observă că graful dat este arbore, pentru că numărul
                muchiilor este cu 1 mai mic decât numărul nodurilor.

            </div>
        </div>
        <div class="text-box">
            <h1>Subiectul II. Problema 3</h1>
            <div class="other-box">
                Considerăm codificarea binară a caracterelor, în care fiecărui simbol îi revine reprezentarea pe 8 biți
                a codului său ASCII. De exemplu, caracterului <i><b>'A'</b></i>, având codul ASCII <i><b>65</b></i>, îi
                va corespunde reprezentarea
                binară <i><b>01000001</b></i>. Scrieți un program C++ care să conțină următoarele funcții:<br>
                <div><br>&nbsp &nbsp &nbsp &nbsp <b>a)</b>&nbsp Funcția <i><b>convert_char</i></b> primește ca argument
                    un
                    caracter și construiește un tablou cu 8 elemente 0 sau 1, reprezentând codificarea binară a
                    caracterului primit.</div>
                <div><br>&nbsp &nbsp &nbsp &nbsp <b>b)</b>&nbsp Funcția <i><b>convert_string</b></i> primește ca
                    argument un
                    șir de
                    caractere s și construiește o matrice cu n linii și 8 coloane (unde n este lungimea șirului s),
                    linia i a matricei reprezentând codificarea binară a caracterului de pe poziția i din șir. </div>
                <div><br>&nbsp &nbsp &nbsp &nbsp <b>c)</b>&nbsp Funcția <i><b>submatrix_size</b></i> primește ca
                    argument o
                    matrice m formată doar din elemente 0 și 1 (precum și dimensiunile sale) și determină dimensiunea
                    celei mai mari submatrice pătratice a lui m conținând elemente având toate aceeași valoare (fie 0,
                    fie 1).</div>
                <div><b><br>Observație:</b>&nbsp Funcțiile pot avea și alte argumente față de cele specificate mai sus.
                </div>
                <div><br>Programul va citi de la tastatură un șir de caractere s și va afișa rezultatul determinat de
                    funcția <i><b>submatrix_size</b></i> aplicată pe matricea construită de <b><i>convert_string</i></b>
                    aplicată asupra lui s.</div>
                <div><b>Exemplu:</b>&nbsp Pentru șirul de caractere s = "IDEEA", se va afișa 3, matricea corespunzătoare
                    fiind:</div>
                <div class="img-center">
                    <img src="1.jpg" width="370">
                </div>
            </div>
            <div class="text-explicatie">
                O problemă de implementare destul de simplă. În enunț scrie că funcțiile pot avea și alți parametri pe
                lângă cei dați, așa că am transmis toate tablourile ca parametri. Pentru <i><b>convert_char</b></i> aflu
                valoarea
                fiecărui bit al lui chr, folosind operații pe biți, și îl pun la poziția corespunzătoare în vectorul
                bin. În funcția <i><b>convert_string</b></i> nu fac decât să apelez <i><b>convert_char</b></i> pentru
                fiecare linie a matricei.<br><br>

                În funcția <i><b>submatrix_size</b></i> parcurg matricea, iar pentru fiecare poziție (i,j) aflu lungimea
                maximă a unei
                submatrice pătratice cu colțul stânga-sus în (i,j). Pentru asta am apelat o funcție
                auxiliară, ij_length. În această funcție încerc să măresc cât mai mult lungimea submatricei curente,
                având grijă să nu ies din matricea mare. La fiecare pas verific dacă vreun element proaspăt adăugat la
                submatrice este diferit de m[i][j]. Dacă da, lungimea actuală nu este validă, răspunsul fiind len−1. La
                finalul funcției, trebuie de asemenea returnat len-1, căci poate n-am întâmpinat niciun element diferit
                de m[i][j] pentru nicio valoare posibilă a lui len.
            </div>
            <div class="code-block">
                <div class="code-text">
                    <img src="testimg.png" width="700" height="950" alt="image">
                </div>
            </div>
            <div class="text-explicatie">
                Complexitatea funcției <i><b>submatrix_size</b></i> este O(n<sup>4</sup>), dar cum numărul de coloane
                ale matricei este limitat
                la 8, o putem considera O(n<sup>2</sup>) cu o constanta foarte mare ( 576 = 8 * 36 * 2 : 8 de la len-ul
                maxim, 36
                *2= ( 8 * 9 / 2 ) * 2 de la verificările corespunzătoare fiecărui len de la 1 la 8). Cred că aceasta
                soluție ar fi obținut punctaj maxim, dar eu unul aș fi aplicat un algoritm mult mai bun, ce folosește
                programare dinamică, cu constanta 2: <br> <br>
                Fie următoarea dinamică: dp[i][j] = dimensiunea maximă a unei submatrice pătratică care conține numai
                elemente cu valoarea x și care are colțul din dreapta-jos în 9i,j). Recurența este destul de cunoscută:
                <img class="img-center" src="dptest.png" width="800" alt="image">
                Explicația este că dp[i−1][j]+1 ne spune care e lungimea maximă pe verticală, dp[i][j−1]+1 pe
                orizontală, iar dp[i−1][j−1]+1 pe diagonală. Dintre cele trei valori trebuie să alegem minimul, ca să
                fim siguri că submatricea nu conține niciun element diferit de x. Vom construi așadar două dinamici: una
                pentru 0 și una pentru 1. De aici vine constanta 2 din spatele complexității de O(n<sup>2</sup>). Iată
                implementarea
                acestei idei:
            </div>
            <div class="code-block">
                <div class="code-text">
                    <img src="ad2.png" width="900" alt="image">
                </div>
            </div>
        </div>
        <div class="text-box">
            <h1>Subiectul II. Problema 4</h1>
            <div class="other-box">
                Fie multimedia S = {1,2, … ,n} unde n > = 4 este un număr natural multiplu de 4. Scrieți un program C++
                care:
            </div>
            <div class="text-explicatie">
                Prima cerință este trivială, așa că trecem la <b>b</b>: Observăm că dacă
                cuplăm 1 cu n, 2 cu n−1, 3 cu n−2 etc., obținem n/2 perechi de sume egale. Cum n este multiplu
                de 4, n/2 va fi număr par, așa că putem pune o jumătate dintre perechi în mulțimea <b>A</b>și cealaltă
                jumătate în mulțimea <b>B</b>. Structura mulțimilor va fi:
                <img src="ad3.png" class="img-center" width="500" alt="image">
                <br>Să notăm cu <i><b>sum(X)</b></i> suma elementelor din mulțimea X. Pima observație cu privirea la
                cerință c esta că
                dacă p este impar, nu există soluție. Motivul este că suma numerelor de la 1 la n (să o notăm cu 2 * S )
                este pară, din moment ce n este multiplu de 4. Dacă din S îl scădem pe p, care este impar, vom obține un
                număr impar, deci <i><b>sum(A)</b></i> și <i><b>sum(B)</b></i> nu vor putea fi egale. Dacă în
                schimb p este par, trebuie să
                echilibrăm cele două mulțimi astfel încât <i><b>sum(A’) = sum (B’) = S - p/2</b></i>. (Din mulțimea
                <i><b>A</b></i> o vom forma pe
                <i><b>A’</b></i>, iar din <i><b>B</b> pe <i><b>B’</b></i>) . Avem de analizat următoarele două cazuri:
                    <br>
                    <div class="point"></div>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp p aparține lui <i><b>B</b></i>, p/2
                    impar. Avem p/2 aparține lui <i><b>A</b></i>, așa că putem să-l
                    mutăm pe p/2 din A în B. Obținem <i><b>sum (A’) = sum(A) - p/2 = S - p/2</b></i> și <i><b>sum(B’) =
                            sum(B) - p + p/2 = S - p/2</b></i>
                    <div class="point"></div>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp p aparține lui <i><b>B</b></i>, p/2
                    par. Avem p/2 + 1
                    aparține lui <i><b>A</b></i>. Putem să-i ducem pe p/2 + 1 și pe 1 din <i><b>A</b></i> în
                    <i><b>B</b></i>, iar pe 2 din <i><b>B</b></i> în <i><b>A</b></i>. Obținem astfel
                    <i><b>sum(A’) = sum(A) - p/2 - 1 - 1 + 2 = S - p/2</b></i> și <i><b>sum(B’).= sum (B) - p/2 + 1 + 1
                            - 2 = S - p/2</b></i>
                    <br><br>
                    Iată cum arată implementarea în C++ a acestor idei:
                    <div class="code-block">
                        <div class="code-text">
                            <img src="ad4.png" width="950" alt="image">
                        </div>
                    </div>
            </div>
        </div>
        <div class="text-box">
            <h1>Subiectul III. Problema 1</h1>
            <div class="other-box">
                Într-o urnă se află4 bile de culoare albă și 3 bile de culoare neagră. Se extrag bilele pe rând și se
                reține secvența de 7 culori obținută. Câte astfel de secvențe distincte sunt? <br><br>
                <b>A)</b> &nbsp 210<br>
                <b>B)</b> &nbsp 35<br>
                <b>C)</b> &nbsp 70<br>
                <b>D)</b> &nbsp 840
            </div>
            <div class="text-explicatie">
                Cum bilele sunt de doar două culori, putem spune că două secvențe de bile diferă dacă șirurile formate
                din pozițiile ce conțin bile albe diferă. 
                Numărul secvențelor din urmă este Combinări 4+3 luate câte 4 adică 35. Varianta corectă este <b>B</b>.
            </div>
        </div>
        <div class="text-box">
            <div class="other-box">
                Pentru funcțiile <b>F1</b> și <b>F2</b> definite mai jos, ce valoare va returna apelul
                <i><b>F1(34)</b></i> ?
                <div class="code-block">
                    <img src="ad5.png" width="300" alt="image">
                </div>
            </div>
            <div class="text-explicatie">
                Ca de obicei, la acest tip de exercițiu trebuie să urmărim lanțul de apeluri recursive. De data asta
                avem parte de o situație un pic mai specială, pentru că ni se dau două funcții indirect recursive:
                <i><b>F1</b></i>
                apelează pe <i><b>F2</b></i>, iar <i><b>F2</b></i> pe <i><b>F1</b></i>. Apropo, funcția <i><b>F2</b></i>
                a trebuit declarată înainte de a defini funcția <i><b>F1</b></i>,
                pentru că în definiția ei, <i><b>F1</b></i> se folosește de <i><b>F2</b></i>.
            </div>
            <div class="code-block">
                <img src="ad6.png" width="400" alt="image">
            </div>
        </div>
        <div class="text-box">
            <h1>Subiectul II. Problema 4</h1>
            <div class="other-box">
                Un puzzle Minesweeper este o matrice de n linii și m coloane care conține la fiecare poziție
                numărul 0 (reprezentând un loc liber) sau −1 (reprezentând o mină). Pozițiile adiacente
                poziției (i,j) sunt:
                {(i − 1, j − 1), (i − 1, j), (i − 1, j + 1), (i, j − 1), (i, j + 1), (i + 1, j − 1), (i + 1, j), (i + 1,
                j +
                1)} ⋂ {0, . . . , n − 1} × {0, . . . , m − 1}. O poziție (i,j) din matrice este periculoasă dacă cel
                puțin o poziție din cele maxim 8 poziții adiacente conține o mină. Fie (l,c) o poziție în matrice. Zona
                sigură este compusă din toate pozițiile accesibile din (l,c) urmând un drum format din poziții
                nepericuloase adiacente. Zona activă conține toate pozițiile zonei sigure și pozițiile adiacente zonei
                sigure. Matricea rezultat are aceleași dimensiuni cu puzzle-ul și este definită astfel:<br><br>
                &nbsp &nbsp Dacă ((l,c) conține o mină, matricea rezultat va fi chiar puzzle-ul inițial. <br>
                &nbsp &nbsp Dacă (l,c) nu conține o mină dar este periculoasă, matricea rezultat conține −2 peste tot cu
                excepția poziției (l,c), care conține numărul de mine vecine.<br>
                &nbsp &nbsp Altfel, matricea rezultat conține pe fiecare poziție (i,j) din zona activă numărul de mine
                adiacente poziției (i,j) și −2 în celelalte poziții.<br>
                <img class="img-center" src="ad7.png" width="600" alt="image"><br> <br>
                <b>a)</b> Scrieți matricea rezultat pentru exemplul (IV).
            </div>
            <div class="text-explicatie">
                Ne aflăm în cazul al treilea, pentru că poziția dată nu conține mină, și nu este nici periculoasă. Zona
                activă este reprezentată de toate celulele matricei, cu excepția celor cu valoarea −1. Pe pozițiile
                periculoase punem 1, pentru că sunt adiacente cu o singură mină, în locul celor cu mină punem −2, iar pe
                celelalte le lăsăm 0:
                <img class="img-center" src="ad8.png" width="250" alt="image">
            </div>
            <div class="other-box">
                <b>b)</b> Scrieți în limbajul C++ o funcție care, primind la intrare un puzzle, calculează o matrice (de
                aceleași
                dimensiuni cu puzzle-ul) care conține 0 pe pozițiile nepericuloase și 1 pe pozițiile periculoase.
            </div>
            <div class="text-explicatie">
                Scrieți în limbajul C++ o funcție care, primind la intrare un puzzle, calculează o matrice (de aceleași
                dimensiuni cu puzzle-ul) care conține 0 pe pozițiile nepericuloase și 1 pe pozițiile periculoase.
                <div class="code-block">
                    <img src="ad9.png" width="800" alt="image">
                </div>
            </div>
            <div class="other-box">
                <b>c)</b> Scrieți în limbajul C++ o funcție care:
                <br><br>
                &nbsp &nbsp Primește ca argument o matrice reprezentând puzzle-ul Minesweeper și poziția (l,c). <br>
                &nbsp &nbsp Construiește matricea rezultat după cum este descris mai sus.
            </div>
            <div class="text-explicatie">
                Verificăm mai întâi în ce situație ne aflăm. Primul caz este banal, pur și simplu copiem matricea. În al
                doilea caz, numărăm vecinii lui (l,c) ca la punctul precedent, iar în rest punem −2. Cazul al treilea
                este mai special, pentru că trebuie să determinăm zona activă. Putem face asta printr-o parcurgere BFS
                pe matrice (Algoritmul lui Lee), sau printr-un DFS pe matrice (flood fill). Eu am ales să fac fill,
                pentru că este mai ușor de implementat, fiind o funcție recursivă.
                <div class="code-block">
                    <img src="ad10.png" width="1000" alt="image">
                </div>
            </div>
        </div>
    </div>
    </div>
</body>

</html>